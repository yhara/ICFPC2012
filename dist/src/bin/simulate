#!/usr/bin/env ruby
# coding: utf-8
require 'trollop'
require_relative "../lib/lambda_lifter"

#require_relative "../lib/lambda_lifter/my_solver.rb"
#class LambdaLifter
#  remove_const :Solver
#  Solver = MySolver
#end

class LambdaLifter
  def self.solve!(mine, opts)
    if opts[:route]
      route = opts[:route]
    else
      puts "solving..."
      route = Solver.new(mine.dup).solve
    end

    puts "route: #{route}"
    SdlVisualizer.instance.background_color = [255, 255, 255] if opts[:sdl]

    route.each_char do |cmd|
      break if mine.finished?
      puts mine.ascii_map
      puts "score: #{mine.score}  next command: #{cmd}"

      sleep opts[:wait]

      mine.step!(cmd)
      sdl(mine)
    end
    puts 
    puts "result: #{mine.finished?}"
    puts "score: #{mine.score}"
  end
end

opts = Trollop.options do
  banner "usage: #$0 mapfile"

  opt :route, "ルート (デフォルト: なし(Solverに解かせる))", type: String
  opt :wait, "ウェイト (デフォルト: 0.5秒)", default: 0.5

  opt :sdl, "SDLによる描画を行う", default: false
  opt :scale, "SDLの拡大倍率 (デフォルト: 1.0)", default: nil, type: Float
  opt :interactive, "インタラクティブモード", default: false

  opt :help, "ヘルプ"
end
opts[:sdl] = true if opts[:interactive] || opts[:scale]
Trollop.die "missing filename" if ARGV.size == 0
Trollop.die if opts[:help]

if opts[:sdl]
  require_relative "../../../mygame/sdlview.rb"

  solver_thread = Thread.start{
    mine = LambdaLifter::Mine.new(ARGF.read)
    sdl(mine)
    LambdaLifter.solve!(mine, opts) unless opts[:interactive]
  }
  solver_thread.abort_on_exception = true
  LambdaLifter::SdlVisualizer.instance.scale = opts[:scale]
  LambdaLifter::SdlVisualizer.instance.run(opts)
else
  def sdl(*args); end

  mine = LambdaLifter::Mine.new(ARGF.read)
  LambdaLifter.solve!(mine, opts)
end
