#! /usr/bin/env ruby

require "logger"
require "pathname"
require "timeout"

to_sigint_timeout = 100 + rand(100)
to_sigkill_timeout = 10

#to_sigint_timeout = 2
#to_sigkill_timeout = 0.0001

map_path = Pathname.glob("*.map").first
if !map_path
  puts("no map!")
  exit(EXIT_FAILURE)
end

l = Logger.new(STDOUT)
l.info("timeout is #{to_sigint_timeout} seconds.")
out_r, out_w = *IO.pipe
err_r, err_w = *IO.pipe
pid = spawn("./lifter", in: map_path.to_s, out: out_w, err: err_w)
begin
  timeout(to_sigint_timeout) do
    Process.wait(pid)
    l.info("lifter is finished.")
  end
rescue Timeout::Error
  l.info("timeout #{to_sigint_timeout} seconds and sending SIGINT to lifter...")
  Process.kill(:INT, pid)
  begin
    timeout(to_sigkill_timeout) do
      l.info("sent SIGINT and waiting lifter to exit or #{to_sigkill_timeout} seconds...")
      Process.wait(pid)
      l.info("lifter is finished.")
    end
  rescue Timeout::Error
    l.warn("timeout #{to_sigkill_timeout} seconds and sending SIGKILL to lifter...")
    Process.kill(:KILL, pid)
  end
ensure
  out_w.close
  err_w.close

  l.info(<<EOS)
lifter stdout:
#{out_r.read}
EOS

  s = err_r.read
  if s.length > 0
    l.warn(<<EOS)
lifter stderr:
#{s}
EOS
  end
end
